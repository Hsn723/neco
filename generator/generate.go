package generator

import (
	"context"
	"errors"
	"io"
	"sort"

	"github.com/containers/image/docker"
	"github.com/containers/image/types"
	"github.com/cybozu-go/log"
	"github.com/cybozu-go/neco"
	"github.com/google/go-github/github"
	"github.com/hashicorp/go-version"
)

const (
	sabakanRepo = "//quay.io/cybozu/sabakan"
)

var quayRepos = []string{
	"cke",
	"etcd",
	"omsa",
	"sabakan",
	"serf",
	"vault",
}

var debRepos = []string{
	"etcdpasswd",
	"neco",
}

func render(w io.Writer, release bool, images []*neco.ContainerImage, debs []*neco.DebianPackage) error {
	_, err := io.WriteString(w, "// Code generated by generate-artifacts. DO NOT EDIT.\n")
	if err != nil {
		return err
	}
	if release {
		_, err = io.WriteString(w, "// +build release\n\n")
	} else {
		_, err = io.WriteString(w, "// +build !release\n\n")
	}
	if err != nil {
		return err
	}
	_, err = io.WriteString(w, "package neco\n\n")
	if err != nil {
		return err
	}

	for _, img := range images {
		_, err = io.WriteString(w, img.MarshalGo())
		if err != nil {
			return err
		}
	}

	for _, deb := range debs {
		_, err := io.WriteString(w, deb.MarshalGo())
		if err != nil {
			return err
		}
	}

	return nil
}

// Config defines the parameters for Generate.
type Config struct {
	// quay.io robot user
	User string

	// quay.io robot password
	Password string

	// tag the generated source code as release or not
	Release bool
}

// Generate generates new artifasts.go contents and writes it to out.
func Generate(ctx context.Context, cfg Config, out io.Writer) error {
	images := make([]*neco.ContainerImage, len(quayRepos))
	for i, name := range quayRepos {
		img, err := getLatestImage(ctx, name, cfg)
		if err != nil {
			return err
		}
		images[i] = img
	}

	debs := make([]*neco.DebianPackage, len(debRepos))
	for i, name := range debRepos {
		deb, err := getLatestDeb(ctx, name)
		if err != nil {
			return err
		}
		debs[i] = deb
	}

	return render(out, cfg.Release, images, debs)
}

func getLatestImage(ctx context.Context, name string, cfg Config) (*neco.ContainerImage, error) {
	ref, err := docker.ParseReference("//quay.io/cybozu/" + name)
	if err != nil {
		return nil, err
	}

	sc := &types.SystemContext{
		DockerAuthConfig: &types.DockerAuthConfig{
			Username: cfg.User,
			Password: cfg.Password,
		},
	}
	tags, err := docker.GetRepositoryTags(ctx, sc, ref)
	if err != nil {
		log.Error("failed to get the latest docker image tag", map[string]interface{}{
			"repository": "quay.io/cybozu/" + name,
			log.FnError:  err,
		})
		return nil, err
	}

	versions := make([]*version.Version, len(tags))
	for i, tag := range tags {
		v, err := version.NewVersion(tag)
		if err != nil {
			return nil, err
		}
		versions[i] = v
	}
	sort.Sort(sort.Reverse(version.Collection(versions)))
	return &neco.ContainerImage{
		Name:       name,
		Repository: "quay.io/cybozu/" + name,
		Tag:        versions[0].Original(),
	}, nil
}

func getLatestDeb(ctx context.Context, name string) (*neco.DebianPackage, error) {
	client := github.NewClient(nil)
	release, _, err := client.Repositories.GetLatestRelease(ctx, "cybozu-go", name)
	if err != nil {
		log.Error("failed to get the latest GitHub release", map[string]interface{}{
			"owner":      "cybozu-go",
			"repository": name,
			log.FnError:  err,
		})
		return nil, err
	}
	if release.TagName == nil {
		log.Error("no tagged release", map[string]interface{}{
			"owner":      "cybozu-go",
			"repository": name,
			"release":    release.String(),
		})
		return nil, errors.New("no tagged release")
	}
	return &neco.DebianPackage{
		Name:       name,
		Owner:      "cybozu-go",
		Repository: name,
		Release:    *release.TagName,
	}, nil
}
